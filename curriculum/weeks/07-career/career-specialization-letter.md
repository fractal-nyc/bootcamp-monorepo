Dear Students,


## Intro + Congrats on Phase 1!

I have been meaning to write to you for some time now.

First, I want to say: you have exceeded my expectations this cohort, and you should all be proud of yourselves.

You have met the challenges of software development with verve and tenacity! Good work! Many of you are now far enough advanced and self-sufficient that it hardly makes sense for us to "teach" you anything! Instead, you will make more progress by pursuing your passions with a critical intent, and a desire for challenge.

Perhaps now we are more like guardrails -- we are there to make sure your course stays true. Please use us this way. The most valuable development for your career will be developing an independent trajectory and a sustaining motivation.

So be free, and use us and our school as your stepping stone, a launch pad, an experimental lab, and a home base.

## Oops sorry, this is just the beginning:

HOWEVER, second, you all have a long way to go on your paths, and it is my job to light the way forward.

It is not enough in this industry to merely get a job and coast. You must deeply understand your domain of expertise.

It is often said that there are two types of programmers:
1. Software Engineers
2. Developers

The developer learns just what is needed to be useful and productive in their current job. They learn primarily high-level tools and languages, and they use those high-level tools primarily to arrange and develop "apps". You are all, already, capable of being developers. Congratulations.


On the other hand, the Software Engineer deeply understands the computer -- from the logic to the hardware, operating system, data, memory, assembly language, low-level programming, data structures (actually, not just leetcode), high-level programming, at least a dozen programming languages (enough to know them all), GPU programming, AI, ML, and more.

The Software Engineer does not stop learning to use the computer until he or she has exhausted all available human knowledge and built systems that press against the boundaries of what is theoretically possible.

Ours is the domain of all known techniques and tools to build software, not just the techniques needed to build the latest trends inside of VC-backed startups. Our job is to master our tool. Our tool is code. Code is that language which controls computers. Computers are devices that perform billions or trillions of operations per second. And those operations? They can do "anything" that we can program circuits or signals to do, which is basically... anything. So a software engineer coordinates the use of trillions and trillions of arbitrarily useful actions per second toward any good and useful end. Perhaps that is computing the trajectory of the planets, or control systems on a rocket, or autopilot on an airplane, or (literally) the training of massive intelligent data structures, exploding an entire field of Artificial Intelligence based on theory that was uncovered 60 years ago.

Any of you could learn to do any of these things, and much much more. They are not much more difficult to understand than the applications you have built or imagined so far. Instead, they are more precise, more sophisticated, and they use specific techniques to their advantage.

You need to start on your path as an engineer to begin systematically learning both how computers fundamentally work AND how masters make the computer work for them.

There is no "one correct" way to walk through the domain of programming (and I suppose you could write a graph and a pathfinding algorithm to prove it) but I want to show you a few options that might broaden your horizons, based on my personal opinions.

However, I also want to be clear that some ways of learning are far superior to others (I expect about 10x superior on retention, speed, and happiness are all possible compared to your baseline). I optimize educational pathways for a living, so please consult with me to help plan your learning.

Finally, before I get into it, I just want to explain why we don't structure this part of the curriculum such that everyone goes through it together, like the first few weeks.

The short answer is because we don't know how to make that work. Our program relies deeply on student motivation.

For many of you, your primary motivation is to succeed in your internships, land a good job offer, and begin your careers. And that is what we want for you, too (to accomplish your primary motivations!)

But if we were to just assign more prep and web development practice for everyone, it would mostly be a distraction from the real thing (eg internships) of which you are already capable. Plus, in the real world, you will have some specific job in some specific niche, not just a generic "web development", so the prep may well be misguided.

And for those of you who have a deep yearning to become those Type 1 Software Engineers (and I hope this is most of you, due to the size of the opportunity here), you all will likely want to pursue different focuses as your next stage of development.

Realistically, this means the second half of our program must look like personalized capstones, internships, and intense study (either personally or in small groups).

For that reason, it is hard to "require" anything from you except your persistence. Your 3-5 good effort pull requests each day, and your motivation. If you think this level of independence is bad for your development, please reach out to me so we can develop a plan to enjoy and flourish in independence.

I believe in you. I want you to become engineers. I want to help you all push beyond your limits. I want you to make me proud.


## Specializations:

So, without further ado, here are my recommendations for specializations as an engineer:

### Category 1: Founding Engineer Training

If you want to build companies and products from scratch, you ned to master design, product, project management, distribution, growth, analytics, and of course software development. To do so, there is really no test or course that can teach you like actually launching a product or a game on Product Hunt and Hacker News and Reddit and Twitter.

Most of you should not actually do this unless you need to, because it's impossible to learn in the time we have. Still -- if you gotta do it, there is no time like the present.


### Category 2: Computer Science & Low-level Software Training

You have to seriously learn C/C++. 

If you want to understand things, these are foundational to basically all software. C runs on every device in every country, in outer space, under the ocean...

You need to be able to manage memory and pointers. Your ability to build data structures that you even kind of comprehend literally REQUIRES pointers and memory addresses (you're learning the concept of a "data structure" without knowing what structure the data is taking)

And by the way, what actually IS an array? What tf is a list? Why are there two different words for this? Are they just two ways of saying the same thing? (No.)

These questions require knowledge of C.

As an added benefit, C will help you learn binary and machine code and assembly and compilation and pre-processing and, inevitably, high-level programming like Javascript.

Because Node is written in (guess what?) C++!
And Chrome is written in (??) C++!

If you're struggling with leetcode, this is also the first thing you should be doing to try to fix those knowledge caps, imo.

Of course you're confused by data structures! You've never written one!

My recommendation for this is an intensive study group working through CS50x at a pace of one week per day (I calculated this, and it should be fine), then CSprimer.com or Nand2Tetris depending on if you want to learn more computer science or more hardware.

### Category 3: ML Engineer Training

ML is the most important field of computer science right now, and still will be for at least a decade or two, at this pace of progress.

Very little engineering is being done on top of the massive frontier of discoveries being made by the research community every day. Translating that research into engineering could be your job! And when that engineering IS done, it results in almost absurd, explosive growth -- faster than we have ever seen in history (see Cursor, Windsurf, Lovable, ChatGPT, etc...)

As a bonus, you will learn a lot of python and linear algebra.

My recommendation for this is to host an intense study group on Andrey Karpathy's Zero to Hero, at a rate of One Week Per Day. Then work on FastAI at the same pace. Then (and in parallel) get a personal mentor to talk to you and your study group about AI research (I will introduce you).

I think it's possible to break in at an AI company fairly quickly if you offer yourself as an engineering intern.

### Category 4: Creative Coding, Art, Games, Graphics

Using the computer to express yourself and your ideas creatively is liberating. And unlike writing or drawing, it is a medium that truly 0.001% of the population (or less, perhaps) is really capable of using for their creative projects. Art also speaks to humans directly, and it is one of the most common ways to be recognized as a software engineer. Art often pushed the boundaries of what has been done before, so it also pushes you to use the computer in New Ways.

The most important thing for artists is identifying your artistic vision. Maybe it is transgressive or rebellious or funny or playful or absurd; it is good to have artistic peers, and I can introduce you to some friends of mine once you take this seriously.

Learning how to use the computer in brilliant and unexpected ways is foundational to making unique art. 

For that reason, I recommend a study group working through Nature of Code at a rate of 1 chapter per day, and then Book of Shaders to learn WebGL/GLSL.

After 2 weeks, you should have some art, and then you should start posting it on Twitter and demoing it at demo days.

Learning graphics is highly valuable, there are a lot of computer graphics jobs out there.

### Category 5: AI Coding Training

Windsurf and Claude Code and Cursor and Lovable are some of the fastest growing products in history (in other words: AI Coding Agents)

They, and every company competing, and every company in YC, and every company doing any AI systems, are hiring basically as many talented people as they can possibly hire who know ANYTHING about improving AI coding agents.

There will be trillions of dollars flowing in the development of AI agent tools built on top of the foundational progress from major AI labs.

But did you know that a minimal system like Claude Code and OpenAI's Codex is basically a couple hundred lines of code and a while loop? You could build your own version in a day!

And if you want that sweet AI money, you should do so, and then start improving it at a rapid pace.

This track is about building AI systems seriously, and building things that are better (for you) than Claude Code, better than Cursor, and better than the open source alternatives.

My recommendation is completing this tutorial: https://ampcode.com/how-to-build-an-agent to write a coding agent, then make it a lot better until it is your daily driver that you prefer to Claude Code.

Then talk to Eugene who is weeks into the development of his coding agent; then start reaching out to agent companies with your work.

